<!DOCTYPE html> 
<html lang="es">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Creador de suelos 2D</title>
    <style>
        /* Estilos generales y de la interfaz */
        :root{--ui-bg:#f4f6f8;--accent:#2b7be4;--panel:#ffffff;--muted:#666;--shadow:0 6px 20px rgba(20,30,50,.06);--dark:#1f2937}
        body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial;margin:0;background:var(--ui-bg);color:var(--dark);transition:background-color .3s}
        header{background:var(--panel);padding:12px 18px;display:flex;align-items:center;gap:12px;box-shadow:0 1px 0 rgba(0,0,0,.06)}
        h1{font-size:16px;margin:0;font-weight:600}
        main{display:flex;gap:12px;padding:12px;min-height:calc(100vh - 55px)}
        .sidebar{width:360px;background:var(--panel);padding:16px;border-radius:12px;box-shadow:var(--shadow);height:fit-content;min-height:80vh;overflow:hidden;position:sticky;top:12px}
        .canvas-wrap{flex:1;background:var(--panel);padding:16px;border-radius:12px;display:flex;flex-direction:column;gap:12px;box-shadow:var(--shadow);overflow:hidden}
        canvas{border-radius:8px;border:1px solid #ddd;display:block;width:100%;height:auto;background: repeating-linear-gradient(45deg, #f0f0f0, #f0f0f0 10px, #e0e0e0 10px, #e0e0e0 20px);box-shadow:inset 0 0 10px rgba(0,0,0,.05)}

        /* Estilos de controles (Modificados para ser colapsables) */
        .control-group{margin-bottom:15px;padding-bottom:0;border-bottom:none;} /* Quitamos bordes y padding de la envoltura */
        .control-group-header {
            display: flex;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
            font-weight: 600;
            font-size: 16px;
            color: var(--dark);
            user-select: none;
            transition: color .2s;
        }
        /* Clase espec√≠fica para el encabezado colapsable */
        .collapsible-header {
            cursor: pointer;
        }
        .collapsible-header:hover {
            color: var(--accent);
        }
        .toggle-icon {
            margin-right: 8px;
            transition: transform 0.2s;
            font-size: 12px;
            color: var(--muted);
        }
        .control-group.open .toggle-icon {
            transform: rotate(90deg);
            color: var(--accent);
        }
        .control-group-content {
            max-height: 1000px; /* Valor grande para transici√≥n */
            overflow: hidden;
            transition: max-height 0.4s ease-in-out;
            padding-top: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee; /* Separador inferior */
        }
        .control-group:not(.open) .control-group-content {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        
        /* Estilos espec√≠ficos de sub-controles */
        label{display:block;margin-bottom:5px;font-size:14px;font-weight:500}
        input[type="number"], select{width:100%;padding:8px 10px;border:1px solid #ccc;border-radius:6px;box-sizing:border-box;transition:border-color .2s}
        input[type="number"]:focus, select:focus{border-color:var(--accent);outline:none}
        button{background-color:var(--accent);color:white;padding:10px 15px;border:none;border-radius:6px;cursor:pointer;font-weight:600;transition:background-color .2s, transform .1s}
        button:hover{background-color:#2066c0}
        button:active{transform:scale(0.98)}
        .flex-row{display:flex;gap:10px;margin-bottom:10px}
        .flex-row > * {flex:1}

        /* Tabs de Mobiliario */
        .tabs { display: flex; border-bottom: 2px solid #ddd; margin-bottom: 10px; overflow-x: auto;}
        .tab-button {
            padding: 8px 12px;
            cursor: pointer;
            border: none;
            background: transparent;
            font-weight: 500;
            color: var(--muted);
            margin-bottom: -2px;
            transition: color .2s;
        }
        .tab-button.active {
            color: var(--accent);
            border-bottom: 2px solid var(--accent);
            font-weight: 600;
        }
        .tab-content { padding-top: 5px; }
        .furniture-catalog {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            max-height: 250px;
            overflow-y: auto;
            padding: 5px;
        }
        .furniture-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px 5px;
            border: 1px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            background: #fafafa;
            transition: background .2s, border-color .2s, box-shadow .2s;
            text-align: center;
        }
        .furniture-card:hover {
            background: #eef4ff;
            border-color: var(--accent);
            box-shadow: 0 2px 8px rgba(43, 123, 228, 0.1);
        }
        .furniture-card p { margin: 2px 0; font-size: 10px; line-height: 1.2; color: var(--muted); }
        .furniture-card strong { font-size: 12px; color: var(--dark); }
        .furniture-icon { font-size: 24px; margin-bottom: 4px; } /* Estilo para el emoji */


        /* Estilos de mobiliario en la lista de la sala */
        .furniture-list{max-height:200px;overflow-y:auto;margin-top:10px;padding-right:5px}
        .furniture-item{display:flex;justify-content:space-between;align-items:center;padding:8px 0;border-bottom:1px dashed #eee}
        .furniture-item:last-child{border-bottom:none}
        .furniture-details{font-size:13px}
        .furniture-details p{margin:0}
        .furniture-details strong{display:inline-block;min-width:40px}

        /* Indicador de selecci√≥n */
        .selected-indicator{border:2px solid var(--accent);padding:2px;border-radius:4px;font-size:10px;font-weight:700;color:var(--accent);margin-left:8px}
    </style>
</head>
<body>

    <header>
        <h1>üìê Creador de suelos 2D con mobiliario interactivo (Vista en Planta)</h1>
    </header>

    <main>
        <div class="sidebar">
            <h2>Configuraci√≥n del Dise√±o</h2>

            <!-- SECCI√ìN: DIMENSIONES DE LA SALA (FIJO) -->
            <div class="control-group open">
                <div class="control-group-header">
                    Dimensiones de la Sala (metros)
                </div>
                <div class="control-group-content">
                    <div class="flex-row">
                        <div>
                            <label for="roomW">Ancho (W):</label>
                            <input type="number" id="roomW" value="5" min="1" step="0.1">
                        </div>
                        <div>
                            <label for="roomH">Alto (H):</label>
                            <input type="number" id="roomH" value="4" min="1" step="0.1">
                        </div>
                    </div>
                    <div>
                        <label for="scale">Escala (p√≠xeles por metro):</label>
                        <input type="number" id="scaleInput" value="100" min="10" step="10">
                    </div>
                </div>
            </div>

            <!-- SECCI√ìN: LAMAS DEL SUELO (FIJO) -->
            <div class="control-group open">
                <div class="control-group-header">
                    Lamas del Suelo
                </div>
                <div class="control-group-content">
                    <div class="flex-row">
                        <div>
                            <label for="plankW">Ancho Lama (W):</label>
                            <input type="number" id="plankW" value="0.15" min="0.01" step="0.01">
                        </div>
                        <div>
                            <label for="plankH">Largo Lama (H):</label>
                            <input type="number" id="plankH" value="1.2" min="0.1" step="0.1">
                        </div>
                    </div>
                    <div class="flex-row">
                        <div>
                            <label for="pattern">Patr√≥n:</label>
                            <select id="pattern">
                                <option value="straight">Recto (Straight)</option>
                                <option value="herringbone">Espiga (Herringbone)</option>
                            </select>
                        </div>
                        <div>
                            <label for="stagger">Desfase (%):</label>
                            <input type="number" id="stagger" value="50" min="0" max="100" step="5">
                        </div>
                    </div>
                </div>
            </div>

            <!-- SECCI√ìN: MOBILIARIO (COLAPSABLE) -->
            <div class="control-group open" id="furnitureControlGroup">
                <div class="control-group-header collapsible-header">
                    <span class="toggle-icon">‚ñ∂</span>
                    Cat√°logo de Mobiliario
                </div>
                <div class="control-group-content">
                    <h3>A√±adir Mobiliario R√°pido</h3>
                    
                    <!-- Pesta√±as de categor√≠as de habitaciones -->
                    <div class="tabs" id="furnitureTabs">
                        <!-- Los botones de las pesta√±as se generan aqu√≠ -->
                    </div>

                    <div class="tab-content" id="furnitureCatalog">
                        <!-- Las tarjetas de mobiliario se insertan aqu√≠ -->
                    </div>

                    <h3 style="margin-top: 15px;">Muebles en el Plano</h3>
                    <p style="font-size: 13px; color: var(--muted); margin-bottom: 10px;">
                        Opcional: A√±adir un mueble con dimensiones personalizadas:
                    </p>
                    <div class="flex-row">
                        <input type="number" id="newFurnitureW" placeholder="Ancho (m)" value="0.8" min="0.1" step="0.1">
                        <input type="number" id="newFurnitureH" placeholder="Alto (m)" value="1.5" min="0.1" step="0.1">
                    </div>
                    <button id="addCustomFurnitureButton">A√±adir Mueble Personalizado</button>

                    <div class="furniture-list" id="furnitureList">
                        <!-- Los elementos de mobiliario en la sala se insertan aqu√≠ -->
                    </div>
                </div>
            </div>

            <!-- SECCI√ìN: AN√ÅLISIS DE CORTE (FIJO) -->
            <div class="control-group open">
                <div class="control-group-header">
                    An√°lisis de Corte
                </div>
                <div class="control-group-content">
                    <p>Haz clic para simular las zonas de corte necesarias alrededor del mobiliario.</p>
                    <button id="runAnalysisButton">Simular Adaptaci√≥n de Corte</button>
                </div>
            </div>
        </div>

        <div class="canvas-wrap">
            <h2>Vista del Plano</h2>
            <canvas id="roomPlanCanvas"></canvas>
            <p style="font-size:12px; color:var(--muted); text-align:center;">
                * Selecciona un mueble haciendo clic en √©l en el plano o en la lista. 
                * **Arrastra el mueble seleccionado** (mant√©n presionado el clic izquierdo) para moverlo.
            </p>
        </div>
    </main>

    <script type="module">
        // --- Datos de Mobiliario Predefinido ---
        const PREDEFINED_FURNITURE = {
            'living': [
                // Se a√±ade un campo 'type' para que la funci√≥n de dibujo sepa c√≥mo representarlo visualmente.
                { name: 'Sof√° 3 plazas', w: 2.2, h: 0.9, color: '#f59e0b', icon: 'üõãÔ∏è', type: 'sofa' },
                { name: 'Sof√° 2 plazas', w: 1.6, h: 0.9, color: '#f59e0b', icon: 'üõãÔ∏è', type: 'sofa' },
                { name: 'Mesa de caf√© (Rect.)', w: 1.2, h: 0.6, color: '#10b981', icon: '‚òï', type: 'table_rect' },
                { name: 'Sill√≥n', w: 0.8, h: 0.9, color: '#f59e0b', icon: 'ü™ë', type: 'armchair' },
                { name: 'Mueble TV', w: 1.8, h: 0.45, color: '#6366f1', icon: 'üì∫', type: 'cabinet_low' }
            ],
            'bedroom': [
                { name: 'Cama Matrimonio', w: 1.6, h: 2.0, color: '#ef4444', icon: 'üõå', type: 'bed_double' },
                { name: 'Cama Individual', w: 1.0, h: 2.0, color: '#ef4444', icon: 'üõå', type: 'bed_single' },
                { name: 'Mesita de Noche', w: 0.5, h: 0.4, color: '#10b981', icon: 'üí°', type: 'table_small' },
                { name: 'Armario Doble', w: 1.2, h: 0.6, color: '#6366f1', icon: 'üö™', type: 'cabinet_tall' },
                { name: 'Escritorio', w: 1.4, h: 0.7, color: '#06b6d4', icon: 'üíª', type: 'desk' }
            ],
            'kitchen': [
                { name: 'Mesa Comedor 4p', w: 1.4, h: 0.8, color: '#10b981', icon: 'üçΩÔ∏è', type: 'table_rect' },
                { name: 'Mesa Comedor 6p', w: 1.8, h: 0.9, color: '#10b981', icon: 'üçΩÔ∏è', type: 'table_rect' },
                { name: 'Nevera', w: 0.7, h: 0.7, color: '#94a3b8', icon: 'üßä', type: 'appliance_square' },
                { name: 'Isla de Cocina', w: 1.0, h: 1.8, color: '#6366f1', icon: 'üç≥', type: 'cabinet_low' }
            ]
        };
        const CATEGORY_NAMES = {
            'living': 'Sal√≥n',
            'bedroom': 'Dormitorio',
            'kitchen': 'Cocina/Comedor'
        };


        // --- Variables de Configuraci√≥n y DOM ---
        const canvas = document.getElementById('roomPlanCanvas');
        const ctx = canvas.getContext('2d');
        const roomW = document.getElementById('roomW');
        const roomH = document.getElementById('roomH');
        const scaleInput = document.getElementById('scaleInput');
        const plankW = document.getElementById('plankW');
        const plankH = document.getElementById('plankH');
        const pattern = document.getElementById('pattern');
        const stagger = document.getElementById('stagger');
        const addCustomFurnitureButton = document.getElementById('addCustomFurnitureButton');
        const newFurnitureW = document.getElementById('newFurnitureW');
        const newFurnitureH = document.getElementById('newFurnitureH');
        const furnitureListEl = document.getElementById('furnitureList');
        const furnitureCatalogEl = document.getElementById('furnitureCatalog');
        const furnitureTabsEl = document.getElementById('furnitureTabs');
        const runAnalysisButton = document.getElementById('runAnalysisButton');

        let furniture = [
            // Se a√±aden tipos a los muebles iniciales
            { id: 1, x: 1.0, y: 1.0, w: 0.8, h: 1.5, color: '#6366f1', icon: 'üì¶', type: 'cabinet_tall' }, 
            { id: 2, x: 3.5, y: 2.5, w: 1.2, h: 0.6, color: '#10b981', icon: 'üñºÔ∏è', type: 'cabinet_low' } 
        ];
        let nextFurnitureId = 3;
        let selectedFurniture = null; 
        let adaptedCuts = []; 
        let activeCategory = 'living'; 

        // Variables para la funcionalidad de arrastrar y soltar (Drag and Drop)
        let isDragging = false;
        let dragOffsetX = 0; 
        let dragOffsetY = 0; 

        // --- Funciones de Dibujo (Mejora: Dibujo de Mobiliario como VISTA EN PLANTA) ---

        /**
         * Dibuja una lama individual en el lienzo.
         * (Mantiene la funci√≥n de suelo existente)
         */
        function drawPlank(xPos, yPos, w, h, color) {
            ctx.fillStyle = color;
            ctx.fillRect(xPos, yPos, w, h);
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 1;
            ctx.strokeRect(xPos, yPos, w, h);
        }

        /**
         * Dibuja el patr√≥n de lamas en el plano de la sala.
         * (Mantiene la funci√≥n de suelo existente)
         */
        function drawFloor(roomW_px, roomH_px, plankW_px, plankH_px, currentPattern) {
            const baseColor = '#b58f6e';
            const lightColor = '#c4a78e';
            const staggerPercent = parseFloat(stagger.value) / 100;

            if (currentPattern === 'straight') {
                let y = 0;
                let rowCount = 0;

                while (y < roomH_px) {
                    let x = -(plankH_px * staggerPercent * rowCount) % plankH_px;
                    let plankColor = rowCount % 2 === 0 ? baseColor : lightColor;
                    
                    while (x < roomW_px) {
                        const drawX = Math.max(0, x);
                        const drawW = Math.min(plankH_px, roomW_px - x);
                        
                        if (drawW > 0) {
                            drawPlank(drawX, y, drawW, plankW_px, plankColor);
                        }
                        x += plankH_px;
                    }
                    
                    y += plankW_px;
                    rowCount++;
                }

            } else if (currentPattern === 'herringbone') {
                // Simulaci√≥n de espiga m√°s simple y con textura
                ctx.fillStyle = '#6d5a42'; 
                ctx.fillRect(0, 0, roomW_px, roomH_px);
                
                ctx.strokeStyle = '#5c4c39';
                ctx.lineWidth = 1;
                const spacing = 40; 
                for (let i = -roomH_px; i < roomW_px + roomH_px; i += spacing) {
                    // L√≠neas diagonales /
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i + roomH_px, roomH_px);
                    ctx.stroke();

                    // L√≠neas diagonales \
                    ctx.beginPath();
                    ctx.moveTo(i, roomH_px);
                    ctx.lineTo(i + roomH_px, 0);
                    ctx.stroke();
                }
            }
        }
        
        /**
         * Dibuja un mueble con una representaci√≥n visual m√°s parecida a un plano.
         * @param {object} f Objeto de mobiliario.
         * @param {number} s Escala.
         * @param {boolean} isSelected Indica si est√° seleccionado.
         */
        function drawFurnitureVisual(f, s, isSelected) {
            const fx_px = f.x * s;
            const fy_px = f.y * s;
            const fw_px = f.w * s;
            const fh_px = f.h * s;
            const baseColor = f.color;
            // Un color m√°s claro para el relleno (para un aspecto de plano m√°s limpio)
            const fillColor = isSelected ? baseColor : 'rgba(255, 255, 255, 0.7)'; 
            // Color de la l√≠nea de contorno principal
            const primaryContourColor = isSelected ? 'red' : baseColor; 
            // Color de los detalles internos (respaldos, cajones, etc.)
            const detailColor = 'rgba(31, 41, 55, 0.7)'; 
            const padding = 0.05 * s; // padding para detalles internos (5cm)
            
            // 1. DIBUJAR BASE (Fondo)
            ctx.fillStyle = fillColor;
            ctx.fillRect(fx_px, fy_px, fw_px, fh_px);
            
            // 2. DIBUJAR CONTORNO PRINCIPAL (Grueso)
            ctx.strokeStyle = primaryContourColor;
            ctx.lineWidth = 3;
            ctx.strokeRect(fx_px, fy_px, fw_px, fh_px);
            
            // 3. DIBUJAR DETALLES POR TIPO (L√≠neas finas)
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 1;
            
            switch (f.type) {
                case 'sofa':
                case 'armchair':
                    const backrestH = 0.15 * s; // 15cm de respaldo/apoyabrazos
                    
                    // Respaldo (√°rea m√°s oscura)
                    ctx.fillStyle = detailColor;
                    ctx.fillRect(fx_px, fy_px, fw_px, backrestH);
                    
                    // Asientos (L√≠neas divisorias y l√≠nea de asiento)
                    ctx.strokeStyle = detailColor;
                    ctx.lineWidth = 1.5;
                    const numSeats = f.w > 1.8 ? 3 : (f.w > 1.2 ? 2 : 1);

                    for (let i = 1; i < numSeats; i++) {
                        // L√≠neas verticales para dividir asientos
                        ctx.beginPath();
                        ctx.moveTo(fx_px + fw_px * i / numSeats, fy_px + backrestH);
                        ctx.lineTo(fx_px + fw_px * i / numSeats, fy_px + fh_px);
                        ctx.stroke();
                    }
                    
                    // L√≠nea horizontal que delimita el respaldo
                    ctx.beginPath();
                    ctx.moveTo(fx_px, fy_px + backrestH);
                    ctx.lineTo(fx_px + fw_px, fy_px + backrestH);
                    ctx.stroke();
                    
                    break;

                case 'bed_double':
                case 'bed_single':
                    const headboardH = 0.1 * s; // 10cm de cabecero
                    
                    // Cabecero (l√≠nea doble o √°rea m√°s gruesa)
                    ctx.strokeStyle = detailColor;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(fx_px, fy_px + 2);
                    ctx.lineTo(fx_px + fw_px, fy_px + 2);
                    ctx.stroke();
                    
                    // Almohadas (rect√°ngulos simples)
                    ctx.lineWidth = 1;
                    const numPillows = f.type === 'bed_double' ? 2 : 1;
                    const pillowW = (fw_px - 2 * padding) / numPillows * 0.9;
                    const pillowH = fh_px * 0.1;

                    for (let i = 0; i < numPillows; i++) {
                        const pillowX = fx_px + padding + (fw_px / numPillows) * i + (fw_px / numPillows - pillowW) / 2;
                        ctx.strokeRect(pillowX, fy_px + headboardH + padding, pillowW, pillowH);
                    }
                    
                    // L√≠nea que simula la doblez de la manta
                    ctx.beginPath();
                    ctx.moveTo(fx_px + padding, fy_px + fh_px - fh_px * 0.3);
                    ctx.lineTo(fx_px + fw_px - padding, fy_px + fh_px - fh_px * 0.3);
                    ctx.stroke();

                    break;
                    
                case 'table_rect':
                    // Mesa Rectangular: Patas
                    ctx.strokeStyle = detailColor;
                    ctx.lineWidth = 1;
                    
                    const legSize = 0.03 * s; // 3cm
                    const offset = 0.1 * s; // 10cm desde el borde
                    const corners = [
                        { x: fx_px + offset, y: fy_px + offset },
                        { x: fx_px + fw_px - offset - legSize, y: fy_px + offset },
                        { x: fx_px + offset, y: fy_px + fh_px - offset - legSize },
                        { x: fx_px + fw_px - offset - legSize, y: fy_px + fh_px - offset - legSize }
                    ];

                    ctx.fillStyle = detailColor;
                    corners.forEach(p => {
                        ctx.fillRect(p.x, p.y, legSize, legSize);
                    });
                    
                    break;
                
                case 'cabinet_tall':
                    // Armario Alto: L√≠neas de divisi√≥n de puertas
                    ctx.strokeStyle = detailColor;
                    ctx.lineWidth = 1.5;
                    
                    // L√≠neas divisorias verticales (2 puertas)
                    ctx.beginPath();
                    ctx.moveTo(fx_px + fw_px / 2, fy_px);
                    ctx.lineTo(fx_px + fw_px / 2, fy_px + fh_px);
                    ctx.stroke();
                    
                    // Detalle de los tiradores (l√≠neas cortas horizontales)
                    const handleL = fw_px * 0.1;
                    ctx.beginPath();
                    ctx.moveTo(fx_px + fw_px / 4 - handleL / 2, fy_px + fh_px / 2);
                    ctx.lineTo(fx_px + fw_px / 4 + handleL / 2, fy_px + fh_px / 2);
                    ctx.moveTo(fx_px + fw_px * 3 / 4 - handleL / 2, fy_px + fh_px / 2);
                    ctx.lineTo(fx_px + fw_px * 3 / 4 + handleL / 2, fy_px + fh_px / 2);
                    ctx.stroke();

                    break;
                    
                case 'cabinet_low':
                case 'appliance_square': 
                    // Mueble Bajo / Isla / Electrodom√©stico: Simular encimera
                    ctx.strokeStyle = detailColor;
                    ctx.lineWidth = 1;
                    
                    // L√≠nea de detalle interna (simulando cajones o encimera)
                    ctx.strokeRect(fx_px + padding/2, fy_px + padding/2, fw_px - padding, fh_px - padding);
                    
                    break;
                
                case 'table_small':
                    // Mesita de Noche (o mesa auxiliar)
                    ctx.strokeStyle = detailColor;
                    ctx.lineWidth = 1;
                    
                    // L√≠nea de Caj√≥n (tercio superior)
                    ctx.beginPath();
                    ctx.moveTo(fx_px, fy_px + fh_px / 3);
                    ctx.lineTo(fx_px + fw_px, fy_px + fh_px / 3);
                    ctx.stroke();
                    
                    // Tirador (peque√±a l√≠nea central)
                    const handleLength = fw_px * 0.15;
                    ctx.beginPath();
                    ctx.moveTo(fx_px + fw_px/2 - handleLength/2, fy_px + fh_px/6);
                    ctx.lineTo(fx_px + fw_px/2 + handleLength/2, fy_px + fh_px/6);
                    ctx.stroke();
                    
                    break;
                    
                case 'desk':
                    // Escritorio: Contorno y √°rea de trabajo.
                    ctx.strokeStyle = detailColor;
                    ctx.lineWidth = 1.5;
                    
                    // 'Recorte' para la silla (simulaci√≥n de √°rea abierta)
                    const chairSpaceW = fw_px * 0.4;
                    const chairSpaceH = fh_px * 0.3;
                    
                    // Volver a pintar la base del mueble en el √°rea del hueco
                    ctx.fillStyle = fillColor;
                    ctx.fillRect(fx_px + fw_px / 2 - chairSpaceW / 2, fy_px + fh_px - chairSpaceH, chairSpaceW, chairSpaceH);
                    
                    // Volver a dibujar el contorno del escritorio para que no se vea el hueco
                    ctx.strokeStyle = primaryContourColor;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(fx_px, fy_px, fw_px, fh_px);

                    // L√≠nea que simula el borde de la mesa
                    ctx.strokeStyle = detailColor;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(fx_px, fy_px, fw_px, fh_px - chairSpaceH); // parte superior

                    break;

                default:
                    // Mueble gen√©rico: solo el cuadrado con un contorno.
                    break;
            }

            // 4. INDICADOR DE SELECCI√ìN (Contorno m√°s grueso y de color diferente si est√° seleccionado)
            if (isSelected) {
                ctx.strokeStyle = 'red'; 
                ctx.lineWidth = 5; // M√°s grueso para indicar selecci√≥n
                ctx.strokeRect(fx_px, fy_px, fw_px, fh_px);
            }

            // 5. El icono se ha eliminado de esta parte para un aspecto m√°s limpio y de plano.
        }


        /**
         * Dibuja el plano completo de la sala, incluyendo suelo, mobiliario y cortes.
         */
        function drawRoomPlan() {
            const s = parseFloat(scaleInput.value); // Escala (p√≠xeles/metro)
            const roomW_m = parseFloat(roomW.value);
            const roomH_m = parseFloat(roomH.value);
            const plankW_m = parseFloat(plankW.value);
            const plankH_m = parseFloat(plankH.value);

            // Dimensiones en p√≠xeles
            const roomW_px = roomW_m * s;
            const roomH_px = roomH_m * s;

            // Ajustar el tama√±o del canvas
            canvas.width = roomW_px;
            canvas.height = roomH_px;

            // 1. Dibujar el fondo y el suelo
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawFloor(roomW_px, roomH_px, plankW_m * s, plankH_m * s, pattern.value);

            // 2. Dibujar el mobiliario usando la nueva funci√≥n de visualizaci√≥n
            furniture.forEach(f => {
                const isSelected = selectedFurniture && selectedFurniture.id === f.id;
                drawFurnitureVisual(f, s, isSelected);
            });

            // 3. Dibujar las zonas de corte adaptadas (si se ha ejecutado el an√°lisis)
            adaptedCuts.forEach(cut => {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)'; // Rojo semi-transparente
                ctx.fillRect(cut.x, cut.y, cut.w, cut.h);
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 1;
                ctx.strokeRect(cut.x, cut.y, cut.w, cut.h);
            });

            // 4. Actualizar la lista de mobiliario en la barra lateral
            updateFurnitureList();
        }

        // --- Funciones de Interacci√≥n del Canvas (Drag and Drop) ---

        /**
         * Verifica si un punto (clientX, clientY) est√° dentro de un elemento de mobiliario (f).
         * @param {object} f Objeto de mobiliario.
         * @param {number} clientX Coordenada X del rat√≥n.
         * @param {number} clientY Coordenada Y del rat√≥n.
         * @returns {boolean} True si el punto est√° dentro del mueble.
         */
        function isPointInFurniture(f, clientX, clientY) {
            const s = parseFloat(scaleInput.value);
            const fx_px = f.x * s;
            const fy_px = f.y * s;
            const fw_px = f.w * s;
            const fh_px = f.h * s;

            // Restar las coordenadas del canvas para obtener coordenadas relativas
            const rect = canvas.getBoundingClientRect();
            const canvasX = clientX - rect.left;
            const canvasY = clientY - rect.top;

            return canvasX >= fx_px && canvasX <= fx_px + fw_px &&
                   canvasY >= fy_px && canvasY <= fy_px + fh_px;
        }


        /**
         * Maneja el inicio del arrastre (mousedown).
         * @param {MouseEvent} e Evento del rat√≥n.
         */
        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            const s = parseFloat(scaleInput.value);
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX;
            const clientY = e.clientY;

            // Intentar seleccionar un nuevo mueble (recorrer al rev√©s para seleccionar el de m√°s arriba)
            const clickedFurniture = furniture.slice().reverse().find(f => isPointInFurniture(f, clientX, clientY));

            if (clickedFurniture) {
                // Si se hizo clic en un mueble, este se convierte en el seleccionado y comienza el arrastre
                selectedFurniture = clickedFurniture;
                isDragging = true;
                
                // Calcular el desplazamiento (offset)
                const canvasX = clientX - rect.left;
                const canvasY = clientY - rect.top;
                dragOffsetX = canvasX - (selectedFurniture.x * s);
                dragOffsetY = canvasY - (selectedFurniture.y * s);

                // Redibujar inmediatamente para mostrar el contorno de selecci√≥n
                drawRoomPlan();
            } else {
                // Si no se hizo clic en ning√∫n mueble, deseleccionar
                selectedFurniture = null;
                isDragging = false;
                drawRoomPlan();
            }
        });

        /**
         * Maneja el movimiento del rat√≥n (mousemove).
         * @param {MouseEvent} e Evento del rat√≥n.
         */
        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging || !selectedFurniture) return;

            e.preventDefault();
            const s = parseFloat(scaleInput.value);
            const rect = canvas.getBoundingClientRect();
            const roomW_m = parseFloat(roomW.value);
            const roomH_m = parseFloat(roomH.value);
            
            // Posici√≥n del rat√≥n en coordenadas del canvas
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;

            // Nueva posici√≥n del objeto en p√≠xeles (basada en el rat√≥n y el offset)
            let newX_px = canvasX - dragOffsetX;
            let newY_px = canvasY - dragOffsetY;

            // Restringir la posici√≥n dentro de los l√≠mites de la habitaci√≥n (en p√≠xeles)
            const objW_px = selectedFurniture.w * s;
            const objH_px = selectedFurniture.h * s;
            const roomW_px = roomW_m * s;
            const roomH_px = roomH_m * s;

            // Clamp X
            if (newX_px < 0) newX_px = 0;
            if (newX_px + objW_px > roomW_px) newX_px = roomW_px - objW_px;

            // Clamp Y
            if (newY_px < 0) newY_px = 0;
            if (newY_px + objH_px > roomH_px) newY_px = roomH_px - objH_px;


            // Convertir la nueva posici√≥n a metros y actualizar el objeto
            selectedFurniture.x = newX_px / s;
            selectedFurniture.y = newY_px / s;

            // Redibujar el plano con el objeto en su nueva posici√≥n
            drawRoomPlan();
        });

        /**
         * Maneja el final del arrastre (mouseup).
         */
        canvas.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                drawRoomPlan(); // Asegurar el redibujo final
            }
        });


        // --- Funciones Auxiliares / UI ---

        /**
         * A√±ade un nuevo mueble al centro de la habitaci√≥n, ya sea predefinido o personalizado.
         * @param {number} w Ancho del mueble en metros.
         * @param {number} h Alto del mueble en metros.
         * @param {string} color Color del mueble.
         * @param {string} icon Icono (emoji) del mueble.
         * @param {string} type Tipo de mueble para el dibujo en plano.
         */
        function addNewFurniture(w, h, color, icon = 'üõ†Ô∏è', type = 'generic') {
            const roomW_m = parseFloat(roomW.value);
            const roomH_m = parseFloat(roomH.value);

            if (w > 0 && h > 0 && w <= roomW_m && h <= roomH_m) {
                // Colocar el nuevo mueble en el centro (ligeramente desplazado para que no se superponga con otros centrados)
                const newX = (roomW_m / 2) - (w / 2) + ((nextFurnitureId % 5) * 0.1);
                const newY = (roomH_m / 2) - (h / 2) + ((nextFurnitureId % 5) * 0.1);
                
                furniture.push({ 
                    id: nextFurnitureId++, 
                    x: newX, 
                    y: newY, 
                    w: w, 
                    h: h, 
                    color: color,
                    icon: icon, 
                    type: type // Incluir el tipo
                });
                drawRoomPlan();
            } else {
                console.error("Dimensiones inv√°lidas o m√°s grandes que la habitaci√≥n.");
            }
        }

        /**
         * Renderiza las tarjetas de mobiliario para la categor√≠a activa.
         */
        function renderFurnitureCatalog() {
            const items = PREDEFINED_FURNITURE[activeCategory];
            furnitureCatalogEl.innerHTML = '';
            
            const catalogDiv = document.createElement('div');
            catalogDiv.className = 'furniture-catalog';

            items.forEach(item => {
                const card = document.createElement('div');
                card.className = 'furniture-card';
                card.innerHTML = `
                    <span class="furniture-icon">${item.icon}</span>
                    <strong>${item.name}</strong>
                    <p>${item.w.toFixed(2)}m x ${item.h.toFixed(2)}m</p>
                `;
                card.addEventListener('click', () => {
                    // Ahora se pasa el tipo al a√±adir el mueble
                    addNewFurniture(item.w, item.h, item.color, item.icon, item.type);
                });
                catalogDiv.appendChild(card);
            });

            furnitureCatalogEl.appendChild(catalogDiv);
        }

        /**
         * Renderiza y maneja la interacci√≥n de las pesta√±as de categor√≠as.
         */
        function renderFurnitureTabs() {
            furnitureTabsEl.innerHTML = '';
            Object.keys(CATEGORY_NAMES).forEach(key => {
                const button = document.createElement('button');
                button.className = `tab-button ${key === activeCategory ? 'active' : ''}`;
                button.textContent = CATEGORY_NAMES[key];
                button.dataset.category = key;
                button.addEventListener('click', () => {
                    activeCategory = key;
                    renderFurnitureTabs(); // Redibujar pesta√±as para actualizar el estado 'active'
                    renderFurnitureCatalog(); // Renderizar el cat√°logo de la nueva categor√≠a
                });
                furnitureTabsEl.appendChild(button);
            });
        }

        /**
         * Actualiza el listado de mobiliario en la barra lateral.
         */
        function updateFurnitureList() {
            furnitureListEl.innerHTML = '';

            furniture.forEach(f => {
                const div = document.createElement('div');
                div.className = 'furniture-item';
                div.dataset.id = f.id;
                
                const isSelected = selectedFurniture && selectedFurniture.id === f.id;

                // El icono (f.icon) se mantiene en la lista de la sala
                div.innerHTML = `
                    <div class="furniture-details">
                        <p><span class="furniture-icon" style="font-size: 16px; margin-right: 5px;">${f.icon || '‚ùì'}</span>
                           <strong>Mueble ${f.id}</strong> 
                           ${isSelected ? '<span class="selected-indicator">SELECCIONADO</span>' : ''}
                        </p>
                        <p>Tipo: ${f.type.toUpperCase()}</p>
                        <p>W: ${f.w.toFixed(2)}m, H: ${f.h.toFixed(2)}m</p>
                        <p>Pos: (${f.x.toFixed(2)}, ${f.y.toFixed(2)})</p>
                    </div>
                    <div>
                        <button class="select-btn" data-id="${f.id}" title="Seleccionar/Deseleccionar">üëÅÔ∏è</button>
                        <button class="delete-btn" data-id="${f.id}" title="Eliminar">üóëÔ∏è</button>
                    </div>
                `;
                furnitureListEl.appendChild(div);
            });

            // A√±adir manejadores de eventos a los botones reci√©n creados
            document.querySelectorAll('.delete-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const id = parseInt(e.currentTarget.dataset.id);
                    furniture = furniture.filter(f => f.id !== id);
                    if (selectedFurniture && selectedFurniture.id === id) {
                        selectedFurniture = null;
                    }
                    drawRoomPlan();
                });
            });

            document.querySelectorAll('.select-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const id = parseInt(e.currentTarget.dataset.id);
                    const clickedFurniture = furniture.find(f => f.id === id);
                    if (selectedFurniture && selectedFurniture.id === id) {
                        selectedFurniture = null; // Deseleccionar si ya estaba seleccionado
                    } else {
                        selectedFurniture = clickedFurniture; // Seleccionar
                    }
                    drawRoomPlan();
                });
            });
        }


        /**
         * Simulaci√≥n de un proceso de an√°lisis AI para determinar cortes necesarios.
         */
        function simulateAIAdapt(payload){
            const s = parseFloat(scaleInput.value);
            const cuts = [];
            payload.furniture.forEach(f=>{
                const fx = Math.round(f.x * s);
                const fy = Math.round(f.y * s);
                const fw = Math.round(f.w * s);
                const fh = Math.round(f.h * s);
                // Crear un margen alrededor del mobiliario para adaptar las juntas
                const margin = Math.round(0.1 * s); // Margen de 10cm simulado
                
                // Se genera un corte que cubre el √°rea del mueble m√°s un margen
                cuts.push({x: fx - margin, y: fy - margin, w: fw + margin*2, h: fh + margin*2});
            });
            return cuts;
        }

        /**
         * Inicializa la funcionalidad de colapso de las secciones (estilo explorador de archivos).
         */
        function initializeCollapsibleSections() {
            // Solo aplicar la funcionalidad de colapso al grupo de mobiliario
            const furnitureHeader = document.querySelector('#furnitureControlGroup .collapsible-header');
            if (furnitureHeader) {
                furnitureHeader.addEventListener('click', () => {
                    const group = furnitureHeader.closest('.control-group');
                    group.classList.toggle('open');
                });
            }
        }

        // --- Inicializaci√≥n y Eventos de UI ---

        // Evento para a√±adir mobiliario personalizado
        addCustomFurnitureButton.addEventListener('click', () => {
            const w = parseFloat(newFurnitureW.value);
            const h = parseFloat(newFurnitureH.value);
            // Tipo y icono gen√©ricos para muebles personalizados
            addNewFurniture(w, h, '#7c3aed', 'üõ†Ô∏è', 'generic'); 
        });

        // Evento para simular el an√°lisis de corte
        runAnalysisButton.addEventListener('click', () => {
            // Recoger todos los datos de la interfaz de usuario
            const payload = {
                room: {w: parseFloat(roomW.value), h: parseFloat(roomH.value)},
                plank: {w: parseFloat(plankW.value), h: parseFloat(plankH.value), pattern: pattern.value, stagger: parseFloat(stagger.value)},
                furniture
            };
            
            // Simular el resultado del an√°lisis (las zonas de corte)
            adaptedCuts = simulateAIAdapt(payload);
            drawRoomPlan();
        });


        // Eventos para redibujar el plano cuando cambian los inputs
        [roomW,roomH,scaleInput,plankW,plankH,pattern,stagger].forEach(el=>el.addEventListener('input', () => {
             // Limpiar los cortes simulados al cambiar la configuraci√≥n del suelo
             adaptedCuts = []; 
             drawRoomPlan();
        }));
        
        // --- Inicializaci√≥n ---
        window.onload = () => {
            renderFurnitureTabs();
            renderFurnitureCatalog();
            initializeCollapsibleSections(); // Solo inicializa el colapso para Mobiliario
            drawRoomPlan(); 
        };
        
    </script>
</body>
</html>
